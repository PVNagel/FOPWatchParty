@page "/watchlist"

@using System.Globalization
@using System.Security.Claims;
@using ClassLibrary.Models;
@using System.Net.Http.Headers;
@inject HttpClient httpClient
@inject NavigationManager navigation
@inject AuthenticationStateProvider AuthenticationStateProvider

<h1>Watchlist</h1>

<h2 class="filter-heading">Filter movies</h2>

<form class="filter-form" @onsubmit="@(async () => await FilterMovies(filterYear, filterGenre, filterActor, filterDirector))">
    <InputText id="year" @bind-Value="filterYear" placeholder="Year" />
    <InputText id="director" @bind-Value="filterDirector" placeholder="Director" />
    <InputText id="actor" @bind-Value="filterActor" placeholder="Actor" />
    <select id="genre" @bind="filterGenre">
        <option value="">Genre</option>
        <option value="Action">Action</option>
        <option value="Adventure">Adventure</option>
        <option value="Animation">Animation</option>
        <option value="Biography">Biography</option>
        <option value="Comedy">Comedy</option>
        <option value="Crime">Crime</option>
        <option value="Drama">Drama</option>
        <option value="Documentary">Documentary</option>
        <option value="Family">Family</option>
        <option value="Fantasy">Fantasy</option>
        <option value="History">History</option>
        <option value="Sci-Fi">Sci-Fi</option>
        <option value="Sport">Sport</option>
    </select>
    <button type="submit" class="filter-button">Apply filter</button>
    <button type="reset" class="clear-filter-button" @onclick="ResetFilter">Clear filter</button>
</form>

@if (moviesToWatch == null)
{
    <p><em>Loading...</em></p>
}

else
{
    <table class="table">
        <thead>
            <tr>
                <th @onclick="@(() => SortMoviesBy("Title"))">
                    Title @RenderSortIcon("Title")
                </th>
                <th @onclick="@(() => SortMoviesBy("Released"))">
                    <div class="header-content">
                        Released
                        <span class="sort-icon">@RenderSortIcon("Released")</span>
                    </div>
                </th>
                <th>Genre</th>
                <th>Director</th>
                <th>Actors</th>
                <th @onclick="@(() => SortMoviesBy("IMDb"))">
                    <div class="header-content">
                        IMDb
                        <span class="sort-icon">@RenderSortIcon("IMDb")</span>
                    </div>
                </th>
                <th @onclick="@(() => SortMoviesBy("Runtime"))">
                    <div class="header-content">
                        Runtime
                        <span class="sort-icon">@RenderSortIcon("Runtime")</span>
                    </div>
                </th>
                <th @onclick="@(() => SortMoviesBy("BoxOffice"))">
                    <div class="header-content">
                        Box Office
                        <span class="sort-icon">@RenderSortIcon("BoxOffice")</span>
                    </div>
                </th>
                <th>Awards</th>
                <th @onclick="@(() => SortMoviesBy("InterestedUsers"))">
                    <div class="header-content">
                        Interested
                        <span class="sort-icon">@RenderSortIcon("InterestedUsers")</span>
                    </div>
                </th>
                <th></th>
                <th></th>
            </tr>
        </thead>
        <tbody>
            @foreach (var watchlistMovie in moviesToWatch)
            {
                var movie = watchlistMovie.Movie;
                <tr>
                    <td class="movie-title" @onclick="() => MovieDetails(movie)">@movie.Title</td>
                    <td>@movie.Released</td>
                    <td>@movie.Genre</td>
                    <td>@movie.Director</td>
                    <td>@movie.Actors</td>
                    <td>@movie.imdbRating/10 <br />(@movie.imdbVotes)</td>
                    <td>@movie.Runtime</td>
                    <td>@movie.BoxOffice</td>
                    <td>@movie.Awards</td>
                    <td style="text-align:center">
                        @if (watchlistMovie.InterestedUsersCount > 0)
                        {
                            <span>@watchlistMovie.InterestedUsersCount</span>
                        }
                    </td>
                    <td @onclick="() => MovieDetails(movie)">
                        @if (movie.Poster == "N/A")
                        {
                            <img src="https://i.imgur.com/l1wt1eN.jpg" alt="Default Movie Poster" width="200" height="300" />
                        }
                        else
                        {
                            <img src="@movie.Poster" alt="Movie Poster" width="200" height="300" />
                        }
                    </td>
                    <td>
                        <div class="button-container">
                            <input type="checkbox" @bind="watchlistMovie.IsInterested" @onclick="() => MarkInterested(watchlistMovie)" />
                            <label for="interestedCheckbox">Interested</label>
                            <button class="MoveToWatched-button" @onclick="() => CreateReport(movie)">Report</button>
                            <button class="RemoveFromWatchlist-button" @onclick="() => RemoveFromWatchlist(watchlistMovie)">Remove</button>
                        </div>
                    </td>
                </tr>
            }
        </tbody>
    </table>
}

@code {
    private ClaimsPrincipal user;
    private Movie? movie;
    private List<WatchlistMovie>? moviesToWatch;
    private string? sortBy;
    private bool sortAsc = false;

    private Dictionary<string, (bool IsInterested, int InterestedUsers)> previousStates = new Dictionary<string, (bool, int)>(); 
    private string? filterYear;
    private string? filterGenre;
    private string? filterActor;
    private string? filterDirector;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
            user = authState.User;

            moviesToWatch = await httpClient.GetFromJsonAsync<List<WatchlistMovie>>("https://localhost:7055/api/watchlist/get");

            if (moviesToWatch != null && moviesToWatch.Any())
            {
                // Fetch the interested users count for each movie
                foreach (var watchlistMovie in moviesToWatch)
                {
                    watchlistMovie.InterestedUsersCount = await GetInterestedUsersCount(watchlistMovie.Movie.imdbID);
                }

                SortMoviesBy("IMDb");

                // Get the sub from the claims using the Sub property
                var sub = user?.FindFirst("sub")?.Value;

                if (string.IsNullOrEmpty(sub))
                {
                    // Handle the case where user ID is not available
                    Console.WriteLine("User ID not found.");
                    return;
                }

                // Fetch user's watchlist entries with interest
                var userWatchlist = await httpClient.GetFromJsonAsync<List<FopUserWatchlist>>($"https://localhost:7055/api/watchlist/getuserwatchlist?sub={sub}");

                if (userWatchlist != null)
                {
                    // Mark movies as interested based on the user's watchlist
                    foreach (var watchlistMovie in moviesToWatch)
                    {
                        var userWatchlistEntry = userWatchlist.FirstOrDefault(uw => uw.MovieId == watchlistMovie.MovieId);

                        if (userWatchlistEntry != null)
                        {
                            watchlistMovie.IsInterested = userWatchlistEntry.IsInterested;
                        }
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching watchlist: {ex.Message}");
        }
    }

    private async Task FilterMovies(string year, string genre, string actor, string director)
    {
        try
        {
            // Store the previous states before making changes
            StorePreviousStates();

            moviesToWatch = await httpClient.GetFromJsonAsync<List<WatchlistMovie>>($"https://localhost:7055/api/watchlist/get?year={year}&genre={genre}&actor={actor}&director={director}");

            // Restore the previous states after updating the moviesToWatch list
            RestorePreviousStates();

            SortMoviesBy("IMDb");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching filtered movie data: {ex.Message}");
        }
    }

    private async Task ResetFilter()
    {
        try
        {
            // Store the previous states before making changes
            StorePreviousStates();

            moviesToWatch = await httpClient.GetFromJsonAsync<List<WatchlistMovie>>("https://localhost:7055/api/watchlist/get");

            if (moviesToWatch != null && moviesToWatch.Any())
            {
                SortMoviesBy("IMDb");
            }

            // Restore the previous states after updating the moviesToWatch list
            RestorePreviousStates();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error resetting filter: {ex.Message}");
        }
    }

    private void StorePreviousStates()
    {
        // Store the previous states before making changes
        previousStates.Clear();
        foreach (var watchlistMovie in moviesToWatch)
        {
            previousStates[watchlistMovie.Movie.imdbID] = (watchlistMovie.IsInterested, watchlistMovie.InterestedUsersCount);
        }
    }

    private void RestorePreviousStates()
    {
        // Restore the previous states after updating the moviesToWatch list
        foreach (var watchlistMovie in moviesToWatch)
        {
            if (previousStates.TryGetValue(watchlistMovie.Movie.imdbID, out var state))
            {
                watchlistMovie.IsInterested = state.IsInterested;
                watchlistMovie.InterestedUsersCount = state.InterestedUsers;
            }
        }
    }

    private async Task CreateReport(Movie movie)
    {
        navigation.NavigateTo($"/create-report/{movie.imdbID}");
    }

    private async Task RemoveFromWatchlist(WatchlistMovie watchlistMovie)
    {
        try
        {
            var response = await httpClient.DeleteAsync($"https://localhost:7055/api/watchlist/remove?imdbID={watchlistMovie.Movie.imdbID}");

            if (response.IsSuccessStatusCode)
            {
                moviesToWatch.Remove(watchlistMovie);
                StateHasChanged();
            }
            else
            {
                Console.WriteLine($"Error removing movie from the watchlist. Status code: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error removing movie from the watchlist: {ex.Message}");
        }
    }

    private void SortMoviesBy(string attribute)
    {
        if (sortBy == attribute)
        {
            // Toggle sorting order if the same attribute is clicked again
            sortAsc = !sortAsc;
        }
        else
        {
            // Change sorting attribute and set ascending order by default
            sortBy = attribute;
            sortAsc = false;
        }

        // Perform sorting based on the selected attribute
        switch (attribute)
        {
            case "Title":
                SortMovies(w => w.Movie.Title);
                break;
            case "Released":
                SortMovies(w => ConvertToDateTime(w.Movie.Released));
                break;
            case "IMDb":
                SortMovies(w => RatingNotAvailableCheck(w.Movie.imdbRating));
                break;
            case "Runtime":
                SortMovies(w => GetRuntimeInMinutes(w.Movie.Runtime));
                break;
            case "BoxOffice":
                SortMovies(w => ConvertToBoxOfficeValue(w.Movie.BoxOffice));
                break;
            case "InterestedUsers":
                SortMovies(w => w.InterestedUsersCount);
                break;
        }

        StateHasChanged();
    }

    private void SortMovies<T>(Func<WatchlistMovie, T> keySelector)
    {
        moviesToWatch = sortAsc ? moviesToWatch.OrderBy(keySelector).ToList()
                                : moviesToWatch.OrderByDescending(keySelector).ToList();
    }

    private string RatingNotAvailableCheck(string imdbRating)
    {
        // Treat "N/A" as the lowest value
        if (imdbRating == "N/A")
        {
            return "0.0";
        }
        return imdbRating;
    }

    private DateTime ConvertToDateTime(string dateString)
    {
        if (DateTime.TryParseExact(dateString, "dd MMM yyyy", CultureInfo.InvariantCulture, DateTimeStyles.None, out DateTime result))
        {
            return result;
        }
        // Return DateTime.MinValue if parsing fails
        return DateTime.MinValue;
    }

    private int GetRuntimeInMinutes(string runtime)
    {
        // Extract the numerical part of the runtime string and convert it to an integer
        if (int.TryParse(new string(runtime.Where(char.IsDigit).ToArray()), out int minutes))
        {
            return minutes;
        }
        return 0; // Return 0 if parsing fails
    }

    private static long ConvertToBoxOfficeValue(string boxOffice)
    {
        if (string.IsNullOrWhiteSpace(boxOffice))
        {
            return 0;
        }

        // Remove non-numeric characters and parse the value
        if (long.TryParse(boxOffice.Replace("$", "").Replace(",", ""), out var result))
        {
            return result;
        }

        return 0;
    }

    private async Task MarkInterested(WatchlistMovie watchlistMovie)
    {
        try
        {
            // Get the sub from the claims using the Sub property
            var sub = user?.FindFirst("sub")?.Value;

            if (string.IsNullOrEmpty(sub))
            {
                // Handle the case where user ID is not available
                Console.WriteLine("User ID not found.");
                return;
            }

            // Store the previous interested state
            var previousInterestedState = watchlistMovie.IsInterested;

            // Update the IsInterested property based on the checkbox status
            watchlistMovie.IsInterested = !watchlistMovie.IsInterested;

            // Create a new UserWatchlist entity with the updated interest status
            var fopUserWatchlist = new FopUserWatchlist
                {
                    Sub = sub,
                    MovieId = watchlistMovie.MovieId,
                    IsInterested = watchlistMovie.IsInterested
                };

            // Send the request to mark as interested
            var response = await httpClient.PostAsJsonAsync("https://localhost:7055/api/watchlist/markinterested", fopUserWatchlist);

            if (response.IsSuccessStatusCode)
            {
                // If successful, fetch the updated interested users count
                watchlistMovie.InterestedUsersCount = await GetInterestedUsersCount(watchlistMovie.Movie.imdbID);

                Console.WriteLine($"Marked as {(watchlistMovie.IsInterested ? "interested" : "not interested")} successfully!");
            }
            else
            {
                // If the request fails, revert the checkbox status to its previous state
                watchlistMovie.IsInterested = previousInterestedState;
                Console.WriteLine($"Error marking as interested. Status code: {response.StatusCode}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error marking as interested: {ex.Message}");
        }
    }

    private async Task<int> GetInterestedUsersCount(string imdbID)
    {
        try
        {
            var count = await httpClient.GetFromJsonAsync<int>($"https://localhost:7055/api/watchlist/interesteduserscount?imdbID={imdbID}");
            return count;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error fetching interested users count: {ex.Message}");
            return 0;
        }
    }


    private string RenderSortIcon(string column)
    {
        if (sortBy == column)
        {
            return sortAsc ? "🔼" : "🔽"; // Up arrow for ascending, down arrow for descending
        }
        return string.Empty;
    }

    private void MovieDetails(Movie movie)
    {
        navigation.NavigateTo($"/moviepage/{movie.imdbID}");
    }

    private string GetUserName()
    {
        // Retrieve the user's name from claims
        var nameClaim = user?.FindFirst("name");
        return nameClaim?.Value ?? "Name not found";
    }
}